Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declist funclist
Rule 2     program -> declist
Rule 3     program -> funclist
Rule 4     declist -> declaration
Rule 5     declist -> declist declaration
Rule 6     funclist -> function
Rule 7     funclist -> funclist function
Rule 8     declaration -> type identlist SEMICOLON
Rule 9     identlist -> identifier
Rule 10    identlist -> identlist COMMA identifier
Rule 11    identifier -> ID
Rule 12    identifier -> ID LBRACKET NUMBER RBRACKET
Rule 13    paramlist -> parameter
Rule 14    paramlist -> paramlist COMMA parameter
Rule 15    parameter -> type identifier
Rule 16    function -> type ID LPAREN RPAREN compoundstmt
Rule 17    function -> type ID LPAREN paramlist RPAREN compoundstmt
Rule 18    type -> INT
Rule 19    type -> FLOAT
Rule 20    compoundstmt -> LBRACE RBRACE
Rule 21    compoundstmt -> LBRACE stmtlist RBRACE
Rule 22    compoundstmt -> LBRACE declist stmtlist RBRACE
Rule 23    compoundstmt -> LBRACE declist RBRACE
Rule 24    stmtlist -> stmt
Rule 25    stmtlist -> stmtlist stmt
Rule 26    stmt -> assignstmt
Rule 27    stmt -> callstmt
Rule 28    stmt -> retstmt
Rule 29    stmt -> while
Rule 30    stmt -> for
Rule 31    stmt -> if
Rule 32    stmt -> compoundstmt
Rule 33    stmt -> SEMICOLON
Rule 34    assignstmt -> assign SEMICOLON
Rule 35    assign -> ID EQUAL expr
Rule 36    assign -> ID LBRACKET expr RBRACKET EQUAL expr
Rule 37    callstmt -> call SEMICOLON
Rule 38    call -> ID LPAREN RPAREN
Rule 39    call -> ID LPAREN arglist RPAREN
Rule 40    arglist -> arg
Rule 41    arglist -> arglist COMMA arg
Rule 42    arg -> expr
Rule 43    retstmt -> RETURN SEMICOLON
Rule 44    retstmt -> RETURN expr SEMICOLON
Rule 45    expr -> expr MINUS expr
Rule 46    expr -> expr PLUS expr
Rule 47    expr -> expr MULT expr
Rule 48    expr -> expr DIV expr
Rule 49    expr -> expr LE expr
Rule 50    expr -> expr GE expr
Rule 51    expr -> expr GT expr
Rule 52    expr -> expr LT expr
Rule 53    expr -> expr EQ expr
Rule 54    expr -> expr NE expr
Rule 55    expr -> call
Rule 56    expr -> NUMBER
Rule 57    expr -> FNUMBER
Rule 58    expr -> id
Rule 59    expr -> LPAREN expr RPAREN
Rule 60    id -> ID
Rule 61    id -> ID LBRACKET expr RBRACKET
Rule 62    while -> WHILE LPAREN expr RPAREN stmt
Rule 63    while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON
Rule 64    for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
Rule 65    if -> IF LPAREN expr RPAREN stmt
Rule 66    if -> IF LPAREN expr RPAREN stmt ELSE stmt

Terminals, with rules where they appear

COMMA                : 10 14 41
DIV                  : 48
DO                   : 63
ELSE                 : 66
EQ                   : 53
EQUAL                : 35 36
FLOAT                : 19
FNUMBER              : 57
FOR                  : 64
GE                   : 50
GT                   : 51
ID                   : 11 12 16 17 35 36 38 39 60 61
IF                   : 65 66
INT                  : 18
LBRACE               : 20 21 22 23
LBRACKET             : 12 36 61
LE                   : 49
LPAREN               : 16 17 38 39 59 62 63 64 65 66
LT                   : 52
MINUS                : 45
MULT                 : 47
NE                   : 54
NUMBER               : 12 56
PLUS                 : 46
RBRACE               : 20 21 22 23
RBRACKET             : 12 36 61
RETURN               : 43 44
RPAREN               : 16 17 38 39 59 62 63 64 65 66
SEMICOLON            : 8 33 34 37 43 44 63 64 64
WHILE                : 62 63
error                : 

Nonterminals, with rules where they appear

arg                  : 40 41
arglist              : 39 41
assign               : 34 64 64
assignstmt           : 26
call                 : 37 55
callstmt             : 27
compoundstmt         : 16 17 32
declaration          : 4 5
declist              : 1 2 5 22 23
expr                 : 35 36 36 42 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 59 61 62 63 64 65 66
for                  : 30
funclist             : 1 3 7
function             : 6 7
id                   : 58
identifier           : 9 10 15
identlist            : 8 10
if                   : 31
parameter            : 13 14
paramlist            : 14 17
program              : 0
retstmt              : 28
stmt                 : 24 25 62 63 64 65 66 66
stmtlist             : 21 22 25
type                 : 8 15 16 17
while                : 29

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declist funclist
    (2) program -> . declist
    (3) program -> . funclist
    (4) declist -> . declaration
    (5) declist -> . declist declaration
    (6) funclist -> . function
    (7) funclist -> . funclist function
    (8) declaration -> . type identlist SEMICOLON
    (16) function -> . type ID LPAREN RPAREN compoundstmt
    (17) function -> . type ID LPAREN paramlist RPAREN compoundstmt
    (18) type -> . INT
    (19) type -> . FLOAT

    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    program                        shift and go to state 1
    declist                        shift and go to state 2
    funclist                       shift and go to state 3
    declaration                    shift and go to state 4
    function                       shift and go to state 5
    type                           shift and go to state 6

state 1

    (0) S' -> program .



state 2

    (1) program -> declist . funclist
    (2) program -> declist .
    (5) declist -> declist . declaration
    (6) funclist -> . function
    (7) funclist -> . funclist function
    (8) declaration -> . type identlist SEMICOLON
    (16) function -> . type ID LPAREN RPAREN compoundstmt
    (17) function -> . type ID LPAREN paramlist RPAREN compoundstmt
    (18) type -> . INT
    (19) type -> . FLOAT

    $end            reduce using rule 2 (program -> declist .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    funclist                       shift and go to state 9
    declaration                    shift and go to state 10
    function                       shift and go to state 5
    type                           shift and go to state 6

state 3

    (3) program -> funclist .
    (7) funclist -> funclist . function
    (16) function -> . type ID LPAREN RPAREN compoundstmt
    (17) function -> . type ID LPAREN paramlist RPAREN compoundstmt
    (18) type -> . INT
    (19) type -> . FLOAT

    $end            reduce using rule 3 (program -> funclist .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    function                       shift and go to state 11
    type                           shift and go to state 12

state 4

    (4) declist -> declaration .

    INT             reduce using rule 4 (declist -> declaration .)
    FLOAT           reduce using rule 4 (declist -> declaration .)
    $end            reduce using rule 4 (declist -> declaration .)
    RBRACE          reduce using rule 4 (declist -> declaration .)
    SEMICOLON       reduce using rule 4 (declist -> declaration .)
    RETURN          reduce using rule 4 (declist -> declaration .)
    WHILE           reduce using rule 4 (declist -> declaration .)
    DO              reduce using rule 4 (declist -> declaration .)
    FOR             reduce using rule 4 (declist -> declaration .)
    IF              reduce using rule 4 (declist -> declaration .)
    LBRACE          reduce using rule 4 (declist -> declaration .)
    ID              reduce using rule 4 (declist -> declaration .)


state 5

    (6) funclist -> function .

    INT             reduce using rule 6 (funclist -> function .)
    FLOAT           reduce using rule 6 (funclist -> function .)
    $end            reduce using rule 6 (funclist -> function .)


state 6

    (8) declaration -> type . identlist SEMICOLON
    (16) function -> type . ID LPAREN RPAREN compoundstmt
    (17) function -> type . ID LPAREN paramlist RPAREN compoundstmt
    (9) identlist -> . identifier
    (10) identlist -> . identlist COMMA identifier
    (11) identifier -> . ID
    (12) identifier -> . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 14

    identlist                      shift and go to state 13
    identifier                     shift and go to state 15

state 7

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)


state 8

    (19) type -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)


state 9

    (1) program -> declist funclist .
    (7) funclist -> funclist . function
    (16) function -> . type ID LPAREN RPAREN compoundstmt
    (17) function -> . type ID LPAREN paramlist RPAREN compoundstmt
    (18) type -> . INT
    (19) type -> . FLOAT

    $end            reduce using rule 1 (program -> declist funclist .)
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    function                       shift and go to state 11
    type                           shift and go to state 12

state 10

    (5) declist -> declist declaration .

    INT             reduce using rule 5 (declist -> declist declaration .)
    FLOAT           reduce using rule 5 (declist -> declist declaration .)
    $end            reduce using rule 5 (declist -> declist declaration .)
    RBRACE          reduce using rule 5 (declist -> declist declaration .)
    SEMICOLON       reduce using rule 5 (declist -> declist declaration .)
    RETURN          reduce using rule 5 (declist -> declist declaration .)
    WHILE           reduce using rule 5 (declist -> declist declaration .)
    DO              reduce using rule 5 (declist -> declist declaration .)
    FOR             reduce using rule 5 (declist -> declist declaration .)
    IF              reduce using rule 5 (declist -> declist declaration .)
    LBRACE          reduce using rule 5 (declist -> declist declaration .)
    ID              reduce using rule 5 (declist -> declist declaration .)


state 11

    (7) funclist -> funclist function .

    INT             reduce using rule 7 (funclist -> funclist function .)
    FLOAT           reduce using rule 7 (funclist -> funclist function .)
    $end            reduce using rule 7 (funclist -> funclist function .)


state 12

    (16) function -> type . ID LPAREN RPAREN compoundstmt
    (17) function -> type . ID LPAREN paramlist RPAREN compoundstmt

    ID              shift and go to state 16


state 13

    (8) declaration -> type identlist . SEMICOLON
    (10) identlist -> identlist . COMMA identifier

    SEMICOLON       shift and go to state 17
    COMMA           shift and go to state 18


state 14

    (16) function -> type ID . LPAREN RPAREN compoundstmt
    (17) function -> type ID . LPAREN paramlist RPAREN compoundstmt
    (11) identifier -> ID .
    (12) identifier -> ID . LBRACKET NUMBER RBRACKET

    LPAREN          shift and go to state 19
    SEMICOLON       reduce using rule 11 (identifier -> ID .)
    COMMA           reduce using rule 11 (identifier -> ID .)
    LBRACKET        shift and go to state 20


state 15

    (9) identlist -> identifier .

    SEMICOLON       reduce using rule 9 (identlist -> identifier .)
    COMMA           reduce using rule 9 (identlist -> identifier .)


state 16

    (16) function -> type ID . LPAREN RPAREN compoundstmt
    (17) function -> type ID . LPAREN paramlist RPAREN compoundstmt

    LPAREN          shift and go to state 19


state 17

    (8) declaration -> type identlist SEMICOLON .

    INT             reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    FLOAT           reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    $end            reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    RBRACE          reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    SEMICOLON       reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    RETURN          reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    WHILE           reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    DO              reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    FOR             reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    IF              reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    LBRACE          reduce using rule 8 (declaration -> type identlist SEMICOLON .)
    ID              reduce using rule 8 (declaration -> type identlist SEMICOLON .)


state 18

    (10) identlist -> identlist COMMA . identifier
    (11) identifier -> . ID
    (12) identifier -> . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 22

    identifier                     shift and go to state 21

state 19

    (16) function -> type ID LPAREN . RPAREN compoundstmt
    (17) function -> type ID LPAREN . paramlist RPAREN compoundstmt
    (13) paramlist -> . parameter
    (14) paramlist -> . paramlist COMMA parameter
    (15) parameter -> . type identifier
    (18) type -> . INT
    (19) type -> . FLOAT

    RPAREN          shift and go to state 24
    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    type                           shift and go to state 23
    paramlist                      shift and go to state 25
    parameter                      shift and go to state 26

state 20

    (12) identifier -> ID LBRACKET . NUMBER RBRACKET

    NUMBER          shift and go to state 27


state 21

    (10) identlist -> identlist COMMA identifier .

    SEMICOLON       reduce using rule 10 (identlist -> identlist COMMA identifier .)
    COMMA           reduce using rule 10 (identlist -> identlist COMMA identifier .)


state 22

    (11) identifier -> ID .
    (12) identifier -> ID . LBRACKET NUMBER RBRACKET

    SEMICOLON       reduce using rule 11 (identifier -> ID .)
    COMMA           reduce using rule 11 (identifier -> ID .)
    RPAREN          reduce using rule 11 (identifier -> ID .)
    LBRACKET        shift and go to state 20


state 23

    (15) parameter -> type . identifier
    (11) identifier -> . ID
    (12) identifier -> . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 22

    identifier                     shift and go to state 28

state 24

    (16) function -> type ID LPAREN RPAREN . compoundstmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE

    LBRACE          shift and go to state 30

    compoundstmt                   shift and go to state 29

state 25

    (17) function -> type ID LPAREN paramlist . RPAREN compoundstmt
    (14) paramlist -> paramlist . COMMA parameter

    RPAREN          shift and go to state 31
    COMMA           shift and go to state 32


state 26

    (13) paramlist -> parameter .

    RPAREN          reduce using rule 13 (paramlist -> parameter .)
    COMMA           reduce using rule 13 (paramlist -> parameter .)


state 27

    (12) identifier -> ID LBRACKET NUMBER . RBRACKET

    RBRACKET        shift and go to state 33


state 28

    (15) parameter -> type identifier .

    RPAREN          reduce using rule 15 (parameter -> type identifier .)
    COMMA           reduce using rule 15 (parameter -> type identifier .)


state 29

    (16) function -> type ID LPAREN RPAREN compoundstmt .

    INT             reduce using rule 16 (function -> type ID LPAREN RPAREN compoundstmt .)
    FLOAT           reduce using rule 16 (function -> type ID LPAREN RPAREN compoundstmt .)
    $end            reduce using rule 16 (function -> type ID LPAREN RPAREN compoundstmt .)


state 30

    (20) compoundstmt -> LBRACE . RBRACE
    (21) compoundstmt -> LBRACE . stmtlist RBRACE
    (22) compoundstmt -> LBRACE . declist stmtlist RBRACE
    (23) compoundstmt -> LBRACE . declist RBRACE
    (24) stmtlist -> . stmt
    (25) stmtlist -> . stmtlist stmt
    (4) declist -> . declaration
    (5) declist -> . declist declaration
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (8) declaration -> . type identlist SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (18) type -> . INT
    (19) type -> . FLOAT
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    RBRACE          shift and go to state 34
    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    ID              shift and go to state 54

    stmtlist                       shift and go to state 35
    declist                        shift and go to state 36
    stmt                           shift and go to state 37
    declaration                    shift and go to state 4
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    type                           shift and go to state 46
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 31

    (17) function -> type ID LPAREN paramlist RPAREN . compoundstmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE

    LBRACE          shift and go to state 30

    compoundstmt                   shift and go to state 55

state 32

    (14) paramlist -> paramlist COMMA . parameter
    (15) parameter -> . type identifier
    (18) type -> . INT
    (19) type -> . FLOAT

    INT             shift and go to state 7
    FLOAT           shift and go to state 8

    parameter                      shift and go to state 56
    type                           shift and go to state 23

state 33

    (12) identifier -> ID LBRACKET NUMBER RBRACKET .

    SEMICOLON       reduce using rule 12 (identifier -> ID LBRACKET NUMBER RBRACKET .)
    COMMA           reduce using rule 12 (identifier -> ID LBRACKET NUMBER RBRACKET .)
    RPAREN          reduce using rule 12 (identifier -> ID LBRACKET NUMBER RBRACKET .)


state 34

    (20) compoundstmt -> LBRACE RBRACE .

    INT             reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    FLOAT           reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    $end            reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    RBRACE          reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    RETURN          reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    WHILE           reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    DO              reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    FOR             reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    IF              reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    LBRACE          reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    ID              reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)
    ELSE            reduce using rule 20 (compoundstmt -> LBRACE RBRACE .)


state 35

    (21) compoundstmt -> LBRACE stmtlist . RBRACE
    (25) stmtlist -> stmtlist . stmt
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    RBRACE          shift and go to state 57
    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    stmt                           shift and go to state 58
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 36

    (22) compoundstmt -> LBRACE declist . stmtlist RBRACE
    (23) compoundstmt -> LBRACE declist . RBRACE
    (5) declist -> declist . declaration
    (24) stmtlist -> . stmt
    (25) stmtlist -> . stmtlist stmt
    (8) declaration -> . type identlist SEMICOLON
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (18) type -> . INT
    (19) type -> . FLOAT
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    RBRACE          shift and go to state 60
    SEMICOLON       shift and go to state 45
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    stmtlist                       shift and go to state 59
    declaration                    shift and go to state 10
    stmt                           shift and go to state 37
    type                           shift and go to state 46
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 37

    (24) stmtlist -> stmt .

    RBRACE          reduce using rule 24 (stmtlist -> stmt .)
    SEMICOLON       reduce using rule 24 (stmtlist -> stmt .)
    RETURN          reduce using rule 24 (stmtlist -> stmt .)
    WHILE           reduce using rule 24 (stmtlist -> stmt .)
    DO              reduce using rule 24 (stmtlist -> stmt .)
    FOR             reduce using rule 24 (stmtlist -> stmt .)
    IF              reduce using rule 24 (stmtlist -> stmt .)
    LBRACE          reduce using rule 24 (stmtlist -> stmt .)
    ID              reduce using rule 24 (stmtlist -> stmt .)


state 38

    (26) stmt -> assignstmt .

    RBRACE          reduce using rule 26 (stmt -> assignstmt .)
    SEMICOLON       reduce using rule 26 (stmt -> assignstmt .)
    RETURN          reduce using rule 26 (stmt -> assignstmt .)
    WHILE           reduce using rule 26 (stmt -> assignstmt .)
    DO              reduce using rule 26 (stmt -> assignstmt .)
    FOR             reduce using rule 26 (stmt -> assignstmt .)
    IF              reduce using rule 26 (stmt -> assignstmt .)
    LBRACE          reduce using rule 26 (stmt -> assignstmt .)
    ID              reduce using rule 26 (stmt -> assignstmt .)
    ELSE            reduce using rule 26 (stmt -> assignstmt .)


state 39

    (27) stmt -> callstmt .

    RBRACE          reduce using rule 27 (stmt -> callstmt .)
    SEMICOLON       reduce using rule 27 (stmt -> callstmt .)
    RETURN          reduce using rule 27 (stmt -> callstmt .)
    WHILE           reduce using rule 27 (stmt -> callstmt .)
    DO              reduce using rule 27 (stmt -> callstmt .)
    FOR             reduce using rule 27 (stmt -> callstmt .)
    IF              reduce using rule 27 (stmt -> callstmt .)
    LBRACE          reduce using rule 27 (stmt -> callstmt .)
    ID              reduce using rule 27 (stmt -> callstmt .)
    ELSE            reduce using rule 27 (stmt -> callstmt .)


state 40

    (28) stmt -> retstmt .

    RBRACE          reduce using rule 28 (stmt -> retstmt .)
    SEMICOLON       reduce using rule 28 (stmt -> retstmt .)
    RETURN          reduce using rule 28 (stmt -> retstmt .)
    WHILE           reduce using rule 28 (stmt -> retstmt .)
    DO              reduce using rule 28 (stmt -> retstmt .)
    FOR             reduce using rule 28 (stmt -> retstmt .)
    IF              reduce using rule 28 (stmt -> retstmt .)
    LBRACE          reduce using rule 28 (stmt -> retstmt .)
    ID              reduce using rule 28 (stmt -> retstmt .)
    ELSE            reduce using rule 28 (stmt -> retstmt .)


state 41

    (29) stmt -> while .

    RBRACE          reduce using rule 29 (stmt -> while .)
    SEMICOLON       reduce using rule 29 (stmt -> while .)
    RETURN          reduce using rule 29 (stmt -> while .)
    WHILE           reduce using rule 29 (stmt -> while .)
    DO              reduce using rule 29 (stmt -> while .)
    FOR             reduce using rule 29 (stmt -> while .)
    IF              reduce using rule 29 (stmt -> while .)
    LBRACE          reduce using rule 29 (stmt -> while .)
    ID              reduce using rule 29 (stmt -> while .)
    ELSE            reduce using rule 29 (stmt -> while .)


state 42

    (30) stmt -> for .

    RBRACE          reduce using rule 30 (stmt -> for .)
    SEMICOLON       reduce using rule 30 (stmt -> for .)
    RETURN          reduce using rule 30 (stmt -> for .)
    WHILE           reduce using rule 30 (stmt -> for .)
    DO              reduce using rule 30 (stmt -> for .)
    FOR             reduce using rule 30 (stmt -> for .)
    IF              reduce using rule 30 (stmt -> for .)
    LBRACE          reduce using rule 30 (stmt -> for .)
    ID              reduce using rule 30 (stmt -> for .)
    ELSE            reduce using rule 30 (stmt -> for .)


state 43

    (31) stmt -> if .

    RBRACE          reduce using rule 31 (stmt -> if .)
    SEMICOLON       reduce using rule 31 (stmt -> if .)
    RETURN          reduce using rule 31 (stmt -> if .)
    WHILE           reduce using rule 31 (stmt -> if .)
    DO              reduce using rule 31 (stmt -> if .)
    FOR             reduce using rule 31 (stmt -> if .)
    IF              reduce using rule 31 (stmt -> if .)
    LBRACE          reduce using rule 31 (stmt -> if .)
    ID              reduce using rule 31 (stmt -> if .)
    ELSE            reduce using rule 31 (stmt -> if .)


state 44

    (32) stmt -> compoundstmt .

    RBRACE          reduce using rule 32 (stmt -> compoundstmt .)
    SEMICOLON       reduce using rule 32 (stmt -> compoundstmt .)
    RETURN          reduce using rule 32 (stmt -> compoundstmt .)
    WHILE           reduce using rule 32 (stmt -> compoundstmt .)
    DO              reduce using rule 32 (stmt -> compoundstmt .)
    FOR             reduce using rule 32 (stmt -> compoundstmt .)
    IF              reduce using rule 32 (stmt -> compoundstmt .)
    LBRACE          reduce using rule 32 (stmt -> compoundstmt .)
    ID              reduce using rule 32 (stmt -> compoundstmt .)
    ELSE            reduce using rule 32 (stmt -> compoundstmt .)


state 45

    (33) stmt -> SEMICOLON .

    RBRACE          reduce using rule 33 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 33 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 33 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 33 (stmt -> SEMICOLON .)
    DO              reduce using rule 33 (stmt -> SEMICOLON .)
    FOR             reduce using rule 33 (stmt -> SEMICOLON .)
    IF              reduce using rule 33 (stmt -> SEMICOLON .)
    LBRACE          reduce using rule 33 (stmt -> SEMICOLON .)
    ID              reduce using rule 33 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 33 (stmt -> SEMICOLON .)


state 46

    (8) declaration -> type . identlist SEMICOLON
    (9) identlist -> . identifier
    (10) identlist -> . identlist COMMA identifier
    (11) identifier -> . ID
    (12) identifier -> . ID LBRACKET NUMBER RBRACKET

    ID              shift and go to state 22

    identlist                      shift and go to state 13
    identifier                     shift and go to state 15

state 47

    (34) assignstmt -> assign . SEMICOLON

    SEMICOLON       shift and go to state 61


state 48

    (37) callstmt -> call . SEMICOLON

    SEMICOLON       shift and go to state 62


state 49

    (43) retstmt -> RETURN . SEMICOLON
    (44) retstmt -> RETURN . expr SEMICOLON
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    SEMICOLON       shift and go to state 63
    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 64
    call                           shift and go to state 65
    id                             shift and go to state 68

state 50

    (62) while -> WHILE . LPAREN expr RPAREN stmt

    LPAREN          shift and go to state 71


state 51

    (63) while -> DO . stmt WHILE LPAREN expr RPAREN SEMICOLON
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    stmt                           shift and go to state 72
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 52

    (64) for -> FOR . LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt

    LPAREN          shift and go to state 73


state 53

    (65) if -> IF . LPAREN expr RPAREN stmt
    (66) if -> IF . LPAREN expr RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 74


state 54

    (35) assign -> ID . EQUAL expr
    (36) assign -> ID . LBRACKET expr RBRACKET EQUAL expr
    (38) call -> ID . LPAREN RPAREN
    (39) call -> ID . LPAREN arglist RPAREN

    EQUAL           shift and go to state 75
    LBRACKET        shift and go to state 76
    LPAREN          shift and go to state 77


state 55

    (17) function -> type ID LPAREN paramlist RPAREN compoundstmt .

    INT             reduce using rule 17 (function -> type ID LPAREN paramlist RPAREN compoundstmt .)
    FLOAT           reduce using rule 17 (function -> type ID LPAREN paramlist RPAREN compoundstmt .)
    $end            reduce using rule 17 (function -> type ID LPAREN paramlist RPAREN compoundstmt .)


state 56

    (14) paramlist -> paramlist COMMA parameter .

    RPAREN          reduce using rule 14 (paramlist -> paramlist COMMA parameter .)
    COMMA           reduce using rule 14 (paramlist -> paramlist COMMA parameter .)


state 57

    (21) compoundstmt -> LBRACE stmtlist RBRACE .

    INT             reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    FLOAT           reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    $end            reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    RBRACE          reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    SEMICOLON       reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    RETURN          reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    WHILE           reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    DO              reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    FOR             reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    IF              reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    LBRACE          reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    ID              reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)
    ELSE            reduce using rule 21 (compoundstmt -> LBRACE stmtlist RBRACE .)


state 58

    (25) stmtlist -> stmtlist stmt .

    RBRACE          reduce using rule 25 (stmtlist -> stmtlist stmt .)
    SEMICOLON       reduce using rule 25 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 25 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 25 (stmtlist -> stmtlist stmt .)
    DO              reduce using rule 25 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 25 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 25 (stmtlist -> stmtlist stmt .)
    LBRACE          reduce using rule 25 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 25 (stmtlist -> stmtlist stmt .)


state 59

    (22) compoundstmt -> LBRACE declist stmtlist . RBRACE
    (25) stmtlist -> stmtlist . stmt
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    RBRACE          shift and go to state 78
    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    stmt                           shift and go to state 58
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 60

    (23) compoundstmt -> LBRACE declist RBRACE .

    INT             reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    FLOAT           reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    $end            reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    RBRACE          reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    SEMICOLON       reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    RETURN          reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    WHILE           reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    DO              reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    FOR             reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    IF              reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    LBRACE          reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    ID              reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)
    ELSE            reduce using rule 23 (compoundstmt -> LBRACE declist RBRACE .)


state 61

    (34) assignstmt -> assign SEMICOLON .

    RBRACE          reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    SEMICOLON       reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    RETURN          reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    WHILE           reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    DO              reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    FOR             reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    IF              reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    LBRACE          reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    ID              reduce using rule 34 (assignstmt -> assign SEMICOLON .)
    ELSE            reduce using rule 34 (assignstmt -> assign SEMICOLON .)


state 62

    (37) callstmt -> call SEMICOLON .

    RBRACE          reduce using rule 37 (callstmt -> call SEMICOLON .)
    SEMICOLON       reduce using rule 37 (callstmt -> call SEMICOLON .)
    RETURN          reduce using rule 37 (callstmt -> call SEMICOLON .)
    WHILE           reduce using rule 37 (callstmt -> call SEMICOLON .)
    DO              reduce using rule 37 (callstmt -> call SEMICOLON .)
    FOR             reduce using rule 37 (callstmt -> call SEMICOLON .)
    IF              reduce using rule 37 (callstmt -> call SEMICOLON .)
    LBRACE          reduce using rule 37 (callstmt -> call SEMICOLON .)
    ID              reduce using rule 37 (callstmt -> call SEMICOLON .)
    ELSE            reduce using rule 37 (callstmt -> call SEMICOLON .)


state 63

    (43) retstmt -> RETURN SEMICOLON .

    RBRACE          reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    DO              reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    IF              reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    ID              reduce using rule 43 (retstmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 43 (retstmt -> RETURN SEMICOLON .)


state 64

    (44) retstmt -> RETURN expr . SEMICOLON
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       shift and go to state 79
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 65

    (55) expr -> call .

    SEMICOLON       reduce using rule 55 (expr -> call .)
    MINUS           reduce using rule 55 (expr -> call .)
    PLUS            reduce using rule 55 (expr -> call .)
    MULT            reduce using rule 55 (expr -> call .)
    DIV             reduce using rule 55 (expr -> call .)
    LE              reduce using rule 55 (expr -> call .)
    GE              reduce using rule 55 (expr -> call .)
    GT              reduce using rule 55 (expr -> call .)
    LT              reduce using rule 55 (expr -> call .)
    EQ              reduce using rule 55 (expr -> call .)
    NE              reduce using rule 55 (expr -> call .)
    RPAREN          reduce using rule 55 (expr -> call .)
    RBRACKET        reduce using rule 55 (expr -> call .)
    COMMA           reduce using rule 55 (expr -> call .)


state 66

    (56) expr -> NUMBER .

    SEMICOLON       reduce using rule 56 (expr -> NUMBER .)
    MINUS           reduce using rule 56 (expr -> NUMBER .)
    PLUS            reduce using rule 56 (expr -> NUMBER .)
    MULT            reduce using rule 56 (expr -> NUMBER .)
    DIV             reduce using rule 56 (expr -> NUMBER .)
    LE              reduce using rule 56 (expr -> NUMBER .)
    GE              reduce using rule 56 (expr -> NUMBER .)
    GT              reduce using rule 56 (expr -> NUMBER .)
    LT              reduce using rule 56 (expr -> NUMBER .)
    EQ              reduce using rule 56 (expr -> NUMBER .)
    NE              reduce using rule 56 (expr -> NUMBER .)
    RPAREN          reduce using rule 56 (expr -> NUMBER .)
    RBRACKET        reduce using rule 56 (expr -> NUMBER .)
    COMMA           reduce using rule 56 (expr -> NUMBER .)


state 67

    (57) expr -> FNUMBER .

    SEMICOLON       reduce using rule 57 (expr -> FNUMBER .)
    MINUS           reduce using rule 57 (expr -> FNUMBER .)
    PLUS            reduce using rule 57 (expr -> FNUMBER .)
    MULT            reduce using rule 57 (expr -> FNUMBER .)
    DIV             reduce using rule 57 (expr -> FNUMBER .)
    LE              reduce using rule 57 (expr -> FNUMBER .)
    GE              reduce using rule 57 (expr -> FNUMBER .)
    GT              reduce using rule 57 (expr -> FNUMBER .)
    LT              reduce using rule 57 (expr -> FNUMBER .)
    EQ              reduce using rule 57 (expr -> FNUMBER .)
    NE              reduce using rule 57 (expr -> FNUMBER .)
    RPAREN          reduce using rule 57 (expr -> FNUMBER .)
    RBRACKET        reduce using rule 57 (expr -> FNUMBER .)
    COMMA           reduce using rule 57 (expr -> FNUMBER .)


state 68

    (58) expr -> id .

    SEMICOLON       reduce using rule 58 (expr -> id .)
    MINUS           reduce using rule 58 (expr -> id .)
    PLUS            reduce using rule 58 (expr -> id .)
    MULT            reduce using rule 58 (expr -> id .)
    DIV             reduce using rule 58 (expr -> id .)
    LE              reduce using rule 58 (expr -> id .)
    GE              reduce using rule 58 (expr -> id .)
    GT              reduce using rule 58 (expr -> id .)
    LT              reduce using rule 58 (expr -> id .)
    EQ              reduce using rule 58 (expr -> id .)
    NE              reduce using rule 58 (expr -> id .)
    RPAREN          reduce using rule 58 (expr -> id .)
    RBRACKET        reduce using rule 58 (expr -> id .)
    COMMA           reduce using rule 58 (expr -> id .)


state 69

    (59) expr -> LPAREN . expr RPAREN
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 90
    call                           shift and go to state 65
    id                             shift and go to state 68

state 70

    (38) call -> ID . LPAREN RPAREN
    (39) call -> ID . LPAREN arglist RPAREN
    (60) id -> ID .
    (61) id -> ID . LBRACKET expr RBRACKET

    LPAREN          shift and go to state 77
    SEMICOLON       reduce using rule 60 (id -> ID .)
    MINUS           reduce using rule 60 (id -> ID .)
    PLUS            reduce using rule 60 (id -> ID .)
    MULT            reduce using rule 60 (id -> ID .)
    DIV             reduce using rule 60 (id -> ID .)
    LE              reduce using rule 60 (id -> ID .)
    GE              reduce using rule 60 (id -> ID .)
    GT              reduce using rule 60 (id -> ID .)
    LT              reduce using rule 60 (id -> ID .)
    EQ              reduce using rule 60 (id -> ID .)
    NE              reduce using rule 60 (id -> ID .)
    RPAREN          reduce using rule 60 (id -> ID .)
    RBRACKET        reduce using rule 60 (id -> ID .)
    COMMA           reduce using rule 60 (id -> ID .)
    LBRACKET        shift and go to state 91


state 71

    (62) while -> WHILE LPAREN . expr RPAREN stmt
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 92
    call                           shift and go to state 65
    id                             shift and go to state 68

state 72

    (63) while -> DO stmt . WHILE LPAREN expr RPAREN SEMICOLON

    WHILE           shift and go to state 93


state 73

    (64) for -> FOR LPAREN . assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr

    ID              shift and go to state 95

    assign                         shift and go to state 94

state 74

    (65) if -> IF LPAREN . expr RPAREN stmt
    (66) if -> IF LPAREN . expr RPAREN stmt ELSE stmt
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 96
    call                           shift and go to state 65
    id                             shift and go to state 68

state 75

    (35) assign -> ID EQUAL . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 97
    call                           shift and go to state 65
    id                             shift and go to state 68

state 76

    (36) assign -> ID LBRACKET . expr RBRACKET EQUAL expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 98
    call                           shift and go to state 65
    id                             shift and go to state 68

state 77

    (38) call -> ID LPAREN . RPAREN
    (39) call -> ID LPAREN . arglist RPAREN
    (40) arglist -> . arg
    (41) arglist -> . arglist COMMA arg
    (42) arg -> . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    RPAREN          shift and go to state 99
    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    arglist                        shift and go to state 100
    arg                            shift and go to state 101
    expr                           shift and go to state 102
    call                           shift and go to state 65
    id                             shift and go to state 68

state 78

    (22) compoundstmt -> LBRACE declist stmtlist RBRACE .

    INT             reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    FLOAT           reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    $end            reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    RBRACE          reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    SEMICOLON       reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    RETURN          reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    WHILE           reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    DO              reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    FOR             reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    IF              reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    LBRACE          reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    ID              reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)
    ELSE            reduce using rule 22 (compoundstmt -> LBRACE declist stmtlist RBRACE .)


state 79

    (44) retstmt -> RETURN expr SEMICOLON .

    RBRACE          reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    DO              reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 44 (retstmt -> RETURN expr SEMICOLON .)


state 80

    (45) expr -> expr MINUS . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 103
    call                           shift and go to state 65
    id                             shift and go to state 68

state 81

    (46) expr -> expr PLUS . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 104
    call                           shift and go to state 65
    id                             shift and go to state 68

state 82

    (47) expr -> expr MULT . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 105
    call                           shift and go to state 65
    id                             shift and go to state 68

state 83

    (48) expr -> expr DIV . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 106
    call                           shift and go to state 65
    id                             shift and go to state 68

state 84

    (49) expr -> expr LE . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 107
    call                           shift and go to state 65
    id                             shift and go to state 68

state 85

    (50) expr -> expr GE . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 108
    call                           shift and go to state 65
    id                             shift and go to state 68

state 86

    (51) expr -> expr GT . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 109
    call                           shift and go to state 65
    id                             shift and go to state 68

state 87

    (52) expr -> expr LT . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 110
    call                           shift and go to state 65
    id                             shift and go to state 68

state 88

    (53) expr -> expr EQ . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 111
    call                           shift and go to state 65
    id                             shift and go to state 68

state 89

    (54) expr -> expr NE . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 112
    call                           shift and go to state 65
    id                             shift and go to state 68

state 90

    (59) expr -> LPAREN expr . RPAREN
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    RPAREN          shift and go to state 113
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 91

    (61) id -> ID LBRACKET . expr RBRACKET
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 114
    call                           shift and go to state 65
    id                             shift and go to state 68

state 92

    (62) while -> WHILE LPAREN expr . RPAREN stmt
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    RPAREN          shift and go to state 115
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 93

    (63) while -> DO stmt WHILE . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 116


state 94

    (64) for -> FOR LPAREN assign . SEMICOLON expr SEMICOLON assign RPAREN stmt

    SEMICOLON       shift and go to state 117


state 95

    (35) assign -> ID . EQUAL expr
    (36) assign -> ID . LBRACKET expr RBRACKET EQUAL expr

    EQUAL           shift and go to state 75
    LBRACKET        shift and go to state 76


state 96

    (65) if -> IF LPAREN expr . RPAREN stmt
    (66) if -> IF LPAREN expr . RPAREN stmt ELSE stmt
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    RPAREN          shift and go to state 118
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 97

    (35) assign -> ID EQUAL expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 35 (assign -> ID EQUAL expr .)
    RPAREN          reduce using rule 35 (assign -> ID EQUAL expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 98

    (36) assign -> ID LBRACKET expr . RBRACKET EQUAL expr
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    RBRACKET        shift and go to state 119
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 99

    (38) call -> ID LPAREN RPAREN .

    SEMICOLON       reduce using rule 38 (call -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 38 (call -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 38 (call -> ID LPAREN RPAREN .)
    MULT            reduce using rule 38 (call -> ID LPAREN RPAREN .)
    DIV             reduce using rule 38 (call -> ID LPAREN RPAREN .)
    LE              reduce using rule 38 (call -> ID LPAREN RPAREN .)
    GE              reduce using rule 38 (call -> ID LPAREN RPAREN .)
    GT              reduce using rule 38 (call -> ID LPAREN RPAREN .)
    LT              reduce using rule 38 (call -> ID LPAREN RPAREN .)
    EQ              reduce using rule 38 (call -> ID LPAREN RPAREN .)
    NE              reduce using rule 38 (call -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 38 (call -> ID LPAREN RPAREN .)
    RBRACKET        reduce using rule 38 (call -> ID LPAREN RPAREN .)
    COMMA           reduce using rule 38 (call -> ID LPAREN RPAREN .)


state 100

    (39) call -> ID LPAREN arglist . RPAREN
    (41) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 120
    COMMA           shift and go to state 121


state 101

    (40) arglist -> arg .

    RPAREN          reduce using rule 40 (arglist -> arg .)
    COMMA           reduce using rule 40 (arglist -> arg .)


state 102

    (42) arg -> expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    RPAREN          reduce using rule 42 (arg -> expr .)
    COMMA           reduce using rule 42 (arg -> expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 103

    (45) expr -> expr MINUS expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 45 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 45 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 45 (expr -> expr MINUS expr .)
    LE              reduce using rule 45 (expr -> expr MINUS expr .)
    GE              reduce using rule 45 (expr -> expr MINUS expr .)
    GT              reduce using rule 45 (expr -> expr MINUS expr .)
    LT              reduce using rule 45 (expr -> expr MINUS expr .)
    EQ              reduce using rule 45 (expr -> expr MINUS expr .)
    NE              reduce using rule 45 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 45 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 45 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 45 (expr -> expr MINUS expr .)
    MULT            shift and go to state 82
    DIV             shift and go to state 83

  ! MULT            [ reduce using rule 45 (expr -> expr MINUS expr .) ]
  ! DIV             [ reduce using rule 45 (expr -> expr MINUS expr .) ]
  ! MINUS           [ shift and go to state 80 ]
  ! PLUS            [ shift and go to state 81 ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]


state 104

    (46) expr -> expr PLUS expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 46 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 46 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 46 (expr -> expr PLUS expr .)
    LE              reduce using rule 46 (expr -> expr PLUS expr .)
    GE              reduce using rule 46 (expr -> expr PLUS expr .)
    GT              reduce using rule 46 (expr -> expr PLUS expr .)
    LT              reduce using rule 46 (expr -> expr PLUS expr .)
    EQ              reduce using rule 46 (expr -> expr PLUS expr .)
    NE              reduce using rule 46 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 46 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 46 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 46 (expr -> expr PLUS expr .)
    MULT            shift and go to state 82
    DIV             shift and go to state 83

  ! MULT            [ reduce using rule 46 (expr -> expr PLUS expr .) ]
  ! DIV             [ reduce using rule 46 (expr -> expr PLUS expr .) ]
  ! MINUS           [ shift and go to state 80 ]
  ! PLUS            [ shift and go to state 81 ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]


state 105

    (47) expr -> expr MULT expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 47 (expr -> expr MULT expr .)
    MINUS           reduce using rule 47 (expr -> expr MULT expr .)
    PLUS            reduce using rule 47 (expr -> expr MULT expr .)
    MULT            reduce using rule 47 (expr -> expr MULT expr .)
    DIV             reduce using rule 47 (expr -> expr MULT expr .)
    LE              reduce using rule 47 (expr -> expr MULT expr .)
    GE              reduce using rule 47 (expr -> expr MULT expr .)
    GT              reduce using rule 47 (expr -> expr MULT expr .)
    LT              reduce using rule 47 (expr -> expr MULT expr .)
    EQ              reduce using rule 47 (expr -> expr MULT expr .)
    NE              reduce using rule 47 (expr -> expr MULT expr .)
    RPAREN          reduce using rule 47 (expr -> expr MULT expr .)
    RBRACKET        reduce using rule 47 (expr -> expr MULT expr .)
    COMMA           reduce using rule 47 (expr -> expr MULT expr .)

  ! MINUS           [ shift and go to state 80 ]
  ! PLUS            [ shift and go to state 81 ]
  ! MULT            [ shift and go to state 82 ]
  ! DIV             [ shift and go to state 83 ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]


state 106

    (48) expr -> expr DIV expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 48 (expr -> expr DIV expr .)
    MINUS           reduce using rule 48 (expr -> expr DIV expr .)
    PLUS            reduce using rule 48 (expr -> expr DIV expr .)
    MULT            reduce using rule 48 (expr -> expr DIV expr .)
    DIV             reduce using rule 48 (expr -> expr DIV expr .)
    LE              reduce using rule 48 (expr -> expr DIV expr .)
    GE              reduce using rule 48 (expr -> expr DIV expr .)
    GT              reduce using rule 48 (expr -> expr DIV expr .)
    LT              reduce using rule 48 (expr -> expr DIV expr .)
    EQ              reduce using rule 48 (expr -> expr DIV expr .)
    NE              reduce using rule 48 (expr -> expr DIV expr .)
    RPAREN          reduce using rule 48 (expr -> expr DIV expr .)
    RBRACKET        reduce using rule 48 (expr -> expr DIV expr .)
    COMMA           reduce using rule 48 (expr -> expr DIV expr .)

  ! MINUS           [ shift and go to state 80 ]
  ! PLUS            [ shift and go to state 81 ]
  ! MULT            [ shift and go to state 82 ]
  ! DIV             [ shift and go to state 83 ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]


state 107

    (49) expr -> expr LE expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 49 (expr -> expr LE expr .)
    LE              reduce using rule 49 (expr -> expr LE expr .)
    GE              reduce using rule 49 (expr -> expr LE expr .)
    RPAREN          reduce using rule 49 (expr -> expr LE expr .)
    RBRACKET        reduce using rule 49 (expr -> expr LE expr .)
    COMMA           reduce using rule 49 (expr -> expr LE expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89

  ! MINUS           [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! PLUS            [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! MULT            [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! DIV             [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! GT              [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! LT              [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! EQ              [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! NE              [ reduce using rule 49 (expr -> expr LE expr .) ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]


state 108

    (50) expr -> expr GE expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 50 (expr -> expr GE expr .)
    LE              reduce using rule 50 (expr -> expr GE expr .)
    GE              reduce using rule 50 (expr -> expr GE expr .)
    RPAREN          reduce using rule 50 (expr -> expr GE expr .)
    RBRACKET        reduce using rule 50 (expr -> expr GE expr .)
    COMMA           reduce using rule 50 (expr -> expr GE expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89

  ! MINUS           [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! PLUS            [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! MULT            [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! DIV             [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! GT              [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! LT              [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! EQ              [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! NE              [ reduce using rule 50 (expr -> expr GE expr .) ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]


state 109

    (51) expr -> expr GT expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 51 (expr -> expr GT expr .)
    LE              reduce using rule 51 (expr -> expr GT expr .)
    GE              reduce using rule 51 (expr -> expr GT expr .)
    GT              reduce using rule 51 (expr -> expr GT expr .)
    LT              reduce using rule 51 (expr -> expr GT expr .)
    RPAREN          reduce using rule 51 (expr -> expr GT expr .)
    RBRACKET        reduce using rule 51 (expr -> expr GT expr .)
    COMMA           reduce using rule 51 (expr -> expr GT expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    EQ              shift and go to state 88
    NE              shift and go to state 89

  ! MINUS           [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! PLUS            [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! MULT            [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! DIV             [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! EQ              [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! NE              [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]


state 110

    (52) expr -> expr LT expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 52 (expr -> expr LT expr .)
    LE              reduce using rule 52 (expr -> expr LT expr .)
    GE              reduce using rule 52 (expr -> expr LT expr .)
    GT              reduce using rule 52 (expr -> expr LT expr .)
    LT              reduce using rule 52 (expr -> expr LT expr .)
    RPAREN          reduce using rule 52 (expr -> expr LT expr .)
    RBRACKET        reduce using rule 52 (expr -> expr LT expr .)
    COMMA           reduce using rule 52 (expr -> expr LT expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    EQ              shift and go to state 88
    NE              shift and go to state 89

  ! MINUS           [ reduce using rule 52 (expr -> expr LT expr .) ]
  ! PLUS            [ reduce using rule 52 (expr -> expr LT expr .) ]
  ! MULT            [ reduce using rule 52 (expr -> expr LT expr .) ]
  ! DIV             [ reduce using rule 52 (expr -> expr LT expr .) ]
  ! EQ              [ reduce using rule 52 (expr -> expr LT expr .) ]
  ! NE              [ reduce using rule 52 (expr -> expr LT expr .) ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]


state 111

    (53) expr -> expr EQ expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 53 (expr -> expr EQ expr .)
    LE              reduce using rule 53 (expr -> expr EQ expr .)
    GE              reduce using rule 53 (expr -> expr EQ expr .)
    GT              reduce using rule 53 (expr -> expr EQ expr .)
    LT              reduce using rule 53 (expr -> expr EQ expr .)
    EQ              reduce using rule 53 (expr -> expr EQ expr .)
    NE              reduce using rule 53 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 53 (expr -> expr EQ expr .)
    RBRACKET        reduce using rule 53 (expr -> expr EQ expr .)
    COMMA           reduce using rule 53 (expr -> expr EQ expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83

  ! MINUS           [ reduce using rule 53 (expr -> expr EQ expr .) ]
  ! PLUS            [ reduce using rule 53 (expr -> expr EQ expr .) ]
  ! MULT            [ reduce using rule 53 (expr -> expr EQ expr .) ]
  ! DIV             [ reduce using rule 53 (expr -> expr EQ expr .) ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]


state 112

    (54) expr -> expr NE expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 54 (expr -> expr NE expr .)
    LE              reduce using rule 54 (expr -> expr NE expr .)
    GE              reduce using rule 54 (expr -> expr NE expr .)
    GT              reduce using rule 54 (expr -> expr NE expr .)
    LT              reduce using rule 54 (expr -> expr NE expr .)
    EQ              reduce using rule 54 (expr -> expr NE expr .)
    NE              reduce using rule 54 (expr -> expr NE expr .)
    RPAREN          reduce using rule 54 (expr -> expr NE expr .)
    RBRACKET        reduce using rule 54 (expr -> expr NE expr .)
    COMMA           reduce using rule 54 (expr -> expr NE expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83

  ! MINUS           [ reduce using rule 54 (expr -> expr NE expr .) ]
  ! PLUS            [ reduce using rule 54 (expr -> expr NE expr .) ]
  ! MULT            [ reduce using rule 54 (expr -> expr NE expr .) ]
  ! DIV             [ reduce using rule 54 (expr -> expr NE expr .) ]
  ! LE              [ shift and go to state 84 ]
  ! GE              [ shift and go to state 85 ]
  ! GT              [ shift and go to state 86 ]
  ! LT              [ shift and go to state 87 ]
  ! EQ              [ shift and go to state 88 ]
  ! NE              [ shift and go to state 89 ]


state 113

    (59) expr -> LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    MULT            reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    DIV             reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 59 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 59 (expr -> LPAREN expr RPAREN .)


state 114

    (61) id -> ID LBRACKET expr . RBRACKET
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    RBRACKET        shift and go to state 122
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 115

    (62) while -> WHILE LPAREN expr RPAREN . stmt
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    stmt                           shift and go to state 123
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 116

    (63) while -> DO stmt WHILE LPAREN . expr RPAREN SEMICOLON
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 124
    call                           shift and go to state 65
    id                             shift and go to state 68

state 117

    (64) for -> FOR LPAREN assign SEMICOLON . expr SEMICOLON assign RPAREN stmt
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 125
    call                           shift and go to state 65
    id                             shift and go to state 68

state 118

    (65) if -> IF LPAREN expr RPAREN . stmt
    (66) if -> IF LPAREN expr RPAREN . stmt ELSE stmt
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    stmt                           shift and go to state 126
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 119

    (36) assign -> ID LBRACKET expr RBRACKET . EQUAL expr

    EQUAL           shift and go to state 127


state 120

    (39) call -> ID LPAREN arglist RPAREN .

    SEMICOLON       reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    MINUS           reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    PLUS            reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    MULT            reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    DIV             reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    LE              reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    GE              reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    GT              reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    LT              reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    EQ              reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    NE              reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    RPAREN          reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    RBRACKET        reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)
    COMMA           reduce using rule 39 (call -> ID LPAREN arglist RPAREN .)


state 121

    (41) arglist -> arglist COMMA . arg
    (42) arg -> . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    arg                            shift and go to state 128
    expr                           shift and go to state 102
    call                           shift and go to state 65
    id                             shift and go to state 68

state 122

    (61) id -> ID LBRACKET expr RBRACKET .

    SEMICOLON       reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    MULT            reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    DIV             reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    LE              reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    GE              reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    GT              reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    LT              reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    EQ              reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    NE              reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 61 (id -> ID LBRACKET expr RBRACKET .)


state 123

    (62) while -> WHILE LPAREN expr RPAREN stmt .

    RBRACE          reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    DO              reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    ID              reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 62 (while -> WHILE LPAREN expr RPAREN stmt .)


state 124

    (63) while -> DO stmt WHILE LPAREN expr . RPAREN SEMICOLON
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    RPAREN          shift and go to state 129
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 125

    (64) for -> FOR LPAREN assign SEMICOLON expr . SEMICOLON assign RPAREN stmt
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       shift and go to state 130
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 126

    (65) if -> IF LPAREN expr RPAREN stmt .
    (66) if -> IF LPAREN expr RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    RBRACE          reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    SEMICOLON       reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    DO              reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    IF              reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    LBRACE          reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    ID              reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .)
    ELSE            shift and go to state 131

  ! ELSE            [ reduce using rule 65 (if -> IF LPAREN expr RPAREN stmt .) ]


state 127

    (36) assign -> ID LBRACKET expr RBRACKET EQUAL . expr
    (45) expr -> . expr MINUS expr
    (46) expr -> . expr PLUS expr
    (47) expr -> . expr MULT expr
    (48) expr -> . expr DIV expr
    (49) expr -> . expr LE expr
    (50) expr -> . expr GE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr LT expr
    (53) expr -> . expr EQ expr
    (54) expr -> . expr NE expr
    (55) expr -> . call
    (56) expr -> . NUMBER
    (57) expr -> . FNUMBER
    (58) expr -> . id
    (59) expr -> . LPAREN expr RPAREN
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN
    (60) id -> . ID
    (61) id -> . ID LBRACKET expr RBRACKET

    NUMBER          shift and go to state 66
    FNUMBER         shift and go to state 67
    LPAREN          shift and go to state 69
    ID              shift and go to state 70

    expr                           shift and go to state 132
    call                           shift and go to state 65
    id                             shift and go to state 68

state 128

    (41) arglist -> arglist COMMA arg .

    RPAREN          reduce using rule 41 (arglist -> arglist COMMA arg .)
    COMMA           reduce using rule 41 (arglist -> arglist COMMA arg .)


state 129

    (63) while -> DO stmt WHILE LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 133


state 130

    (64) for -> FOR LPAREN assign SEMICOLON expr SEMICOLON . assign RPAREN stmt
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr

    ID              shift and go to state 95

    assign                         shift and go to state 134

state 131

    (66) if -> IF LPAREN expr RPAREN stmt ELSE . stmt
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    stmt                           shift and go to state 135
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    assign                         shift and go to state 47
    call                           shift and go to state 48

state 132

    (36) assign -> ID LBRACKET expr RBRACKET EQUAL expr .
    (45) expr -> expr . MINUS expr
    (46) expr -> expr . PLUS expr
    (47) expr -> expr . MULT expr
    (48) expr -> expr . DIV expr
    (49) expr -> expr . LE expr
    (50) expr -> expr . GE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . LT expr
    (53) expr -> expr . EQ expr
    (54) expr -> expr . NE expr

    SEMICOLON       reduce using rule 36 (assign -> ID LBRACKET expr RBRACKET EQUAL expr .)
    RPAREN          reduce using rule 36 (assign -> ID LBRACKET expr RBRACKET EQUAL expr .)
    MINUS           shift and go to state 80
    PLUS            shift and go to state 81
    MULT            shift and go to state 82
    DIV             shift and go to state 83
    LE              shift and go to state 84
    GE              shift and go to state 85
    GT              shift and go to state 86
    LT              shift and go to state 87
    EQ              shift and go to state 88
    NE              shift and go to state 89


state 133

    (63) while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .

    RBRACE          reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    SEMICOLON       reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    RETURN          reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    DO              reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    FOR             reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    LBRACE          reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ID              reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)
    ELSE            reduce using rule 63 (while -> DO stmt WHILE LPAREN expr RPAREN SEMICOLON .)


state 134

    (64) for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign . RPAREN stmt

    RPAREN          shift and go to state 136


state 135

    (66) if -> IF LPAREN expr RPAREN stmt ELSE stmt .

    RBRACE          reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    DO              reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    IF              reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    LBRACE          reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ID              reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 66 (if -> IF LPAREN expr RPAREN stmt ELSE stmt .)


state 136

    (64) for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN . stmt
    (26) stmt -> . assignstmt
    (27) stmt -> . callstmt
    (28) stmt -> . retstmt
    (29) stmt -> . while
    (30) stmt -> . for
    (31) stmt -> . if
    (32) stmt -> . compoundstmt
    (33) stmt -> . SEMICOLON
    (34) assignstmt -> . assign SEMICOLON
    (37) callstmt -> . call SEMICOLON
    (43) retstmt -> . RETURN SEMICOLON
    (44) retstmt -> . RETURN expr SEMICOLON
    (62) while -> . WHILE LPAREN expr RPAREN stmt
    (63) while -> . DO stmt WHILE LPAREN expr RPAREN SEMICOLON
    (64) for -> . FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt
    (65) if -> . IF LPAREN expr RPAREN stmt
    (66) if -> . IF LPAREN expr RPAREN stmt ELSE stmt
    (20) compoundstmt -> . LBRACE RBRACE
    (21) compoundstmt -> . LBRACE stmtlist RBRACE
    (22) compoundstmt -> . LBRACE declist stmtlist RBRACE
    (23) compoundstmt -> . LBRACE declist RBRACE
    (35) assign -> . ID EQUAL expr
    (36) assign -> . ID LBRACKET expr RBRACKET EQUAL expr
    (38) call -> . ID LPAREN RPAREN
    (39) call -> . ID LPAREN arglist RPAREN

    SEMICOLON       shift and go to state 45
    RETURN          shift and go to state 49
    WHILE           shift and go to state 50
    DO              shift and go to state 51
    FOR             shift and go to state 52
    IF              shift and go to state 53
    LBRACE          shift and go to state 30
    ID              shift and go to state 54

    assign                         shift and go to state 47
    stmt                           shift and go to state 137
    assignstmt                     shift and go to state 38
    callstmt                       shift and go to state 39
    retstmt                        shift and go to state 40
    while                          shift and go to state 41
    for                            shift and go to state 42
    if                             shift and go to state 43
    compoundstmt                   shift and go to state 44
    call                           shift and go to state 48

state 137

    (64) for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .

    RBRACE          reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    SEMICOLON       reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    RETURN          reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    WHILE           reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    DO              reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    FOR             reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    IF              reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    LBRACE          reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    ID              reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)
    ELSE            reduce using rule 64 (for -> FOR LPAREN assign SEMICOLON expr SEMICOLON assign RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 126 resolved as shift
